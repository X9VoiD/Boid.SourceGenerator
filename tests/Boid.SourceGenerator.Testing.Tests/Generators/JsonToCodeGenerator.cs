using System.Collections.Immutable;
using System.Text;
using System.Text.Json;
using Boid.SourceGenerator.Testing.Tests.Formatters;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Boid.SourceGenerator.Testing.Tests.Generators;

// Adds a 'Person.g.cs' file to the compilation with a 'Person' class in it.
// Then reads all json files tagged with "Person" property:
//
//   <ItemGroup>
//     <AdditionalText Include="Person.json" Person="true" />
//   </ItemGroup>
//
// into 'Person' objects. These are then added to a static 'People' property
// as an array of 'Person'.

public class JsonToCodeGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            var source = """
                // <auto-generated />
                public partial class Person
                {
                    public string Name { get; set; }
                    public int Age { get; set; }
                    public string Gender { get; set; }

                    public Person(string name, int age, string gender)
                    {
                        Name = name;
                        Age = age;
                        Gender = gender;
                    }
                }
                """;
            ctx.AddSource("Person.g.cs", source);
        });

        var people = context.AdditionalTextsProvider
            .Where(t => t.Path.EndsWith(".json"))
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Where(t => IsPersonJson(t.Right, t.Left))
            .Select((t, ct) => t.Left.GetText(ct)!.ToString())
            .Select(EmitObject)
            .Collect();

        context.RegisterSourceOutput(people, (ctx, people) =>
        {
            var source = EmitSource(people);
            ctx.AddSource("Person2.g.cs", source);
        });
    }

    private static bool IsPersonJson(AnalyzerConfigOptionsProvider options, AdditionalText text)
    {
        var option = options.GetOptions(text).TryGetValue("build_metadata.AdditionalFiles.Person", out var value);
        return option && value == "true";
    }

    private static string EmitSource(ImmutableArray<ObjectCreationExpressionSyntax> people)
    {
        var stringBuilder = new StringBuilder();

        stringBuilder.AppendLine("// <auto-generated />");

        var personClass =
            SyntaxFactory.ClassDeclaration("Person")
            .WithModifiers(
                SyntaxFactory.TokenList(
                    SyntaxFactory.Token(SyntaxKind.PartialKeyword)))
            .WithMembers(
                SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                    SyntaxFactory.PropertyDeclaration(
                        SyntaxFactory.ArrayType(
                            SyntaxFactory.IdentifierName("Person"))
                        .WithRankSpecifiers(
                            SyntaxFactory.SingletonList(
                                SyntaxFactory.ArrayRankSpecifier(
                                    SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                        SyntaxFactory.OmittedArraySizeExpression())))),
                        SyntaxFactory.Identifier("People"))
                    .WithModifiers(
                        SyntaxFactory.TokenList(new[]
                        {
                            SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                            SyntaxFactory.Token(SyntaxKind.StaticKeyword)
                        }))
                    .WithAccessorList(
                        SyntaxFactory.AccessorList(
                            SyntaxFactory.SingletonList(
                                SyntaxFactory.AccessorDeclaration(
                                    SyntaxKind.GetAccessorDeclaration)
                                .WithSemicolonToken(
                                    SyntaxFactory.Token(SyntaxKind.SemicolonToken)))))
                    .WithInitializer(
                        SyntaxFactory.EqualsValueClause(
                            EmitArray(people)))
                    .WithSemicolonToken(
                        SyntaxFactory.Token(SyntaxKind.SemicolonToken))))
            .NormalizeWhitespace(eol: Environment.NewLine);

        stringBuilder.Append(Format(personClass).ToString());

        return stringBuilder.ToString();
    }

    private static SyntaxNode Format(SyntaxNode node)
    {
        return new WhitespaceHumanizer().Visit(CSharpSyntaxTree.ParseText(node.ToString()).GetRoot());
    }

    private static ArrayCreationExpressionSyntax EmitArray(ImmutableArray<ObjectCreationExpressionSyntax> objects)
    {
        return
            SyntaxFactory.ArrayCreationExpression(
                SyntaxFactory.ArrayType(
                    SyntaxFactory.IdentifierName(nameof(Person)))
                .WithRankSpecifiers(
                    SyntaxFactory.SingletonList(
                        SyntaxFactory.ArrayRankSpecifier(
                            SyntaxFactory.SingletonSeparatedList<ExpressionSyntax>(
                                SyntaxFactory.OmittedArraySizeExpression())))))
            .WithInitializer(
                SyntaxFactory.InitializerExpression(
                    SyntaxKind.ArrayInitializerExpression,
                    SyntaxFactory.SeparatedList<ExpressionSyntax>(objects)));
    }

    private static ObjectCreationExpressionSyntax EmitObject(string json, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        var person = JsonSerializer.Deserialize<Person>(json, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });

        return
            SyntaxFactory.ObjectCreationExpression(
                SyntaxFactory.IdentifierName(nameof(Person)))
            .WithArgumentList(
                SyntaxFactory.ArgumentList(
                    SyntaxFactory.SeparatedList(new[]
                    {
                        SyntaxFactory.Argument(
                            SyntaxFactory.LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                SyntaxFactory.Literal(person!.Name))),
                        SyntaxFactory.Argument(
                            SyntaxFactory.LiteralExpression(
                                SyntaxKind.NumericLiteralExpression,
                                SyntaxFactory.Literal(person.Age))),
                        SyntaxFactory.Argument(
                            SyntaxFactory.LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                SyntaxFactory.Literal(person.Gender)))
                    })));
    }
}

internal class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Gender { get; set; }

    public Person(string name, int age, string gender)
    {
        Name = name;
        Age = age;
        Gender = gender;
    }
}